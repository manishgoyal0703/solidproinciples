Design patterns: 

	Creational: Patterns deal with the process of creation of the objects of classes.
		1. Builder
		2. Simple factory
		3. Factory method
		4. Prototype
		5. Singleton
		6. Abstract factory
		7. Object pool
		
	Structural: Patterns deal with how classes and objects are arranged and composed.
		8. Adapter
		9. Bridge
		10. Decorator
		11. Composite
		12. Facade
		13. Flyweight
		14. Proxy
	
	Behavioural: Patterns describe how classes and objects interact and communicate with each other.
		15. Chain of Responsibility
		16. Command
		17. Interpreter
		18. Mediator
		19. Iterator
		20. Memento
		21. Observer
		22. State
		23. Strategy
		24. Template Method
		25. Visitor
		26. Null Object
	
	
	
1. Builder : we have a complex process to construct an object involving multiple steps, then builder design pattern can help us.
			In Builder we remove the logic related to object construction from "client" code & abstract it in separate class.
			
			Role: 
				Builder: provide interface for creating parts of the product.
				ConcreteBuilder: Construct parts & assembles final product. Keeps track of product it creates.
				Director: Uses builder to construct object. knows the steps & their sequence to build product.
				Product: Final complex object that we want to create.
			
			Ex: Constructing a Immutable class where we don't know the sequence of parameter needs to be passed.
				Constructing a user class where we need to construct the address class first.
				Real life Example: StringBuilder, Calender.builder
				
				
				
2. Simple factory: Here we simply move the instantiation logic to a separate class and most commonly to a static method of this class.
					It's simply a method that encapsulates object instantiation.
					Ex: if(pudding) provide pudding object else if(cake) provide cake object.
					Real life Example: java.text.NumberFormat class has getInstance method
					
					Pitfalls: Start with simple factory then evolve into factory method design pattern.
					
					
3. Factory method: Most versatile design pattern, when we want to move the object creation logic from our code to a separate class.
					We use this pattern when we do not know in advance which class we may need to instantiate beforehand 
					& also to allow new classes to be added to system and handle their creation without affecting client code.
					We let subclasses decide which object to instantiate by overriding the factory method.
					Ex:template method and abstract factory makes use of factory method design pattern. java.util.collection has an 
					abstract method called iterator().
					
					pitfalls: you need to start from beginning. It's not easy to refactor existing code into factory method pattern.
					More complex to implement. 
					
4. 	Prototype : When we have a complex object that is costly to create. To create more instances os such class, 
				we use an existing instance as our prototype. 
				Prototype will allow us to make copies of existing object & save us from having to re-create objects from scratch.
				Abstract prototype : declares a method for cloning itself.
				
				While using Cloneable pleas give attention to the shallow/deep copy of the references. Immutable fields on clones save the 
				trouble of deep copy. 
				Shallow copy will have all the calues of cloned object and in deep copy it will reset it to the initial ones.
				
				Make sure to reset the mutable state of the object before returning the prototype. It's a good idea to implement 
				this in method to allow subclasses to initialize themselves.
				
				Clone method is protected in Object class and must be overridden to be public to be callable from outside the class.
				
				Clonable is a marker interface, an indication that the class support cloning.
				
				Prototypes are useful when working with Composite and Decorator patterns.
				Ex: Object.clone()
					
		Pitfalls: 
				Sublclasses may not be able to support clone so the code becomes complicated as you have to code for situations where 
				an implementation may not support clone.
				If large number of mutable obejct states are there then it is complicated.
				
				
				
5. Abstract Factory: Abstract Factory patterns work around a super-factory which creates other factories.
						The Abstract Factory design pattern is a creational pattern that provides an interface for creating families 
						of related objects without specifying their concrete classes. It allows clients to create objects without 
						knowledge of their specific implementations, promoting flexibility and loose coupling in the code.
						Ex: xml.parsers.DocumentBuilderFactory		


6. Singleton : Only once instance per application or accessible globally through a single point.
				Volatile forces value read/write from main memory instead of cache.
				Ex: Java.lang.Runtime
				
				
7. Object pool : In our system if cost of creating an instance of a class is high and we need a large number of 
                 objects of this class for short duration, then we can use object pool.
				 
				 Implementation: 
					1. A thread safe caching of objects should be done in pool. 
					2. Methods to acquire and release objects should be provided & pool reset cached objects before giving them out.
				Ex: org.apache.commons.dbcp.BasicDataSource
				

8. Adapter: we have an existing object which provides the functionality which client needs. But client code can't 
			use this object because it expects an object with different interface.
			
			Using adapter design pattern we make this existing object work with client by adapting the object to client's 
			expected interface.
			This pattern is also called as wrapper as it "wraps" existing object.
			
			Implementation: 
				1. How much work the adaptor does depends upon the differences between target interface and object being adapted. 
					If method arguments are same or similar adaptor has very less work to do.
				2. Using class adaptor "allows" you to override some of the adaptee's behaviour. but this has to be avoided as you 
					end up with adapter that behaves differently than adaptee. Fixing defect is not easy anymore!
				3. Using Object adapter allows you to potentially change the adaptee object to one of it's subclasses.
				
				Design considerations: 
					In java a "class adapter" may not be possible if both the target and adaptee are concrete classes. In such cases the 
					object adater is the only solution.
				Example : InputStreamReader and OutputStreamReader classes are examples of Object adapters.
				
				
9. Bridge: Our implementations and abstractions are generally coupled to each other in normal inheritance. Using bridge pattern
			we can decouple them so they can both change without affecting each other.
			
			Implementation: 
			1. We can achieve this by creating two separate inheritance hierarchies; one for implementation and another for abstraction.
			2. we use composition to bridge these two hierarchies.
			
			3. In case we are ever going to have a single implementation then we can skip creating abstract implementor.
			4. Abstraction can decide on it's own which concrete implementor to use in it's constructor or we can delegate that decision to a third
			class. In last approach abstraction remains unaware of concrete implementors & provided greater de-coupling.
			Benefits: you can change the abstraction without changing implementation.
			Ex: DriverManager -> getConnection(), (mysql.jdbc.Driver -> connect(), oracle -> connect()).
				Collections.newSetFromMap()
			
			
10. Decorator:  When we want to enhance behaviour of our existing object dynamically as and when required then we can use decorator design pattern.
				Decorator wraps an object within itself and provides same interface as the wrapped object. So the client of original object
				doesn't need to change.
				A decorator provides alternative to subclassing for extending functionality of existing classes.
				Decorator can be abstrract as well. Depends on the the subclasses functionality.
				
				Considerations: 
				Decorators support recursive composition, and so this pattern lends itself to creation of lots of small objects that add
				"just a little bit" functionality. Code using these objects becomes difficult to debug.
				Ex: BufferedOutputStream class decorates the outputStream object and adds buffering to file writing operation. This improves
				the disk I/O performance by reducing number of writes.

11. Composite: We have a part-whole relationship or hierarchy of objects and we want to be able to treat all objects in this hierarchy uniformly.
				It's the functional enhancement of the composite concept from oops.
				
				If leaf objects can be repeated in the hierarchy then shared leaf nodes be used to save memory and initialization costs.
				But again the number the number of nodes is major factor as using cache for small total number of nodes may cost more.
				
				
12. Facade: 1. Client has to interact with lasrge number of interfaces and classes in a subsystem to get result. So client gets tightly coupled 
			with those interfaces and classes. facade solves this problem.
			2. Facade provides a simple and unified interface to a subsystem. Client interacts with just the facade now to get the result.
			3. Facade is a great solution to simplify dependencies. It allows you to have a weak coupling between subsystems.
			4. If your only concern is coupling of client code to subsystem specific classes and not worried about simplification provided by facade, then you can use abstract factory pattern in place of facade.
			
			Implementation: 
				1. We start by creating a class that will serve as a facade.
				2. We determine the overall use cases/ tasks that the subsystem is used for.
				3. We write a method that exposes each use case/task.
				4. This method takes care of working with different classes of subsystem.
				
			Considerations:
				1. A Facade should minimize the complexity of subsystem and provide usable interface.
				2. You can have an interface or abstract class for Facade or client can use different subclasses to talk to different subsystem implementations.
				
			Ex: Java.net.URL -> openStream() method.			
			
13. Flyweight: 	1. Our system needs a large number of a particular class & maintaining these instances is a performance concern.
				2. Flyweight allows us to share an Object in multiple contexts. But instead of sharing entire object, which may not be feasible,
				we divide object into two parts: intrinsic(state that is shared in every context) & extrinsic(context specific state) state. we create objects with only intrinsic state and share them in multiple contexts.
				3. Client or user of object provides the extrinsic state to object to carry out it's functionality.
				4. We provide a factory so client can get required flyweight objects based on some key to identify flyweight.
				
				Considerations:
				1. A factory is necessary with flyweight dp as client code needs easy way to get hold of shared flyweight. Also number of shared instances can be large so a central place is good strategy to keep track all of them.
				2. Flyweight's intrinsic state should be immutable for successful use of flyweight dp.
				3. Some other dp like state or strategy can make best use of fyweight dp.
			
			Example : Integer, Short, Byte -> valueOf() merthod is serve as factory method.
			
				Pitfalls: Runtime cost may be added for maintaing the extrinsic state. Client code has to either maintain it or compute it every time
				it needs to use flyweight.
				
14. Proxy:  what is proxy ? 
			-> We need to provide a placeholder or surrogate to another object.
			-> Proxy acts on behalf of the object. types: Protection, Remote, Virtual proxy.
			
			Implementation: 
			1. Proxy must implement same interface as the real subject.
			2. We can either create actual object later when required or ask for the one in constructor.
			3. In method implementations of proxy we implement proxy's functionality before delegating to real object.
			
			Ex: Hibernate uses a proxy to load collections of value types.
			
15. Chain of Responsibility: 
				
				
				
				
				
				
				
			
			
			
			
				
				
			
			
			
			
				
				
				
	